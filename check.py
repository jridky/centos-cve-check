#!/usr/bin/python3
# -*- encoding: utf-8 -*-

import koji as brew
import bugzilla as bz
import logging as log
import optparse
import string
import random
import sys
import git
import os
import re

ZSTREAM = None
LAST_NVR = None
NVRS = {}
NVRSZ = {}
BZRE = re.compile(r"(?:(?:bug|bz|rhbz)\s*#?|#)\s*(\d+)", re.IGNORECASE)
CVERE = re.compile(r"(CVE-[0-9]{4}-[0-9]{4,})", re.IGNORECASE)

def randomString(stringLength):
    letters = string.ascii_letters
    return "".join(random.choice(letters) for i in range(stringLength))

def split_rpm_name(name):
    m = re.search(r'(.*)-(.*)-(.*?)\.(el.*)', name)
    if m:
        (name, version, release, platform) = m.groups()
    else:   
        (name, version, release, platform) = split_module_name(name)

    return (name, version, release, platform)

def split_module_name(name):
    m = re.search(r'(.*)-(.*)-(.*?)\+(el.*)', name)
    if m:
        (name, version, release, platform) = m.groups()
        return (name, version, release, platform)
    else:
        log.error('Invalid name: %s\n' % name)
        sys.exit(2)

def atoi(text):
    return int(text) if text.isdigit() else text

def natural_keys(text):
    '''
    alist.sort(key=natural_keys) sorts in human order
    http://nedbatchelder.com/blog/200712/human_sorting.html
    (See Toothy's implementation in the comments)
    '''
    return [ atoi(c) for c in re.split(r'(\d+)', text) ]

def get_info_from_brew(check_pkg):
    global LAST_NVR

    log.info("Pulling info about " + check_pkg + " from brew.")

    # Get info about build
    try:
        checked_build = brew_proxy.getBuild(check_pkg) 
    except Exception as e:
        log.error("NVR - " + str(e))
        sys.exit(2)

    # Check for output of brew query
    if checked_build == None:
        log.error("Invalid NVR")
        sys.exit(2)

    # Eliminate containers and others
    if "source" not in checked_build['extra']:
        log.error("Only RPM builds allowed.")
        sys.exit(2)
   
    last_commit = None
    # Get info about released versions
    log.info("Pulling info about latest build for " + checked_build['name'] + " from brew.") 
    for entry in brew_proxy.getLatestBuilds('rhel-' + checked_build['release'].split("el")[1][0] + '-latest-build', package=checked_build['name']):
        LAST_NVR = entry['nvr'] 
        last_commit = brew_proxy.getBuild(LAST_NVR)['extra']['source']['original_url']

    if last_commit == None:
        return "", checked_build['extra']['source']['original_url'].split("#")[1]
    return last_commit.split("#")[1], checked_build['extra']['source']['original_url'].split("#")[1]

def pull_git_for_pkg(pkg_name, commit_from, commit_to):

    log.info("Making temporary clone of " + pkg_name + " repository. This can take a while.")

    uid = randomString(10)
    repo = git.Repo.clone_from("git://pkgs.devel.redhat.com/rpms/" + pkg_name + ".git", "/tmp/" + pkg_name + "-" + uid)

    bzs = {}
    lineREres = re.compile(r"^\s*-?\s*%s" % "Resolves?:", re.IGNORECASE)
    lineRErel = re.compile(r"^\s*-?\s*%s" % "Related?:", re.IGNORECASE)
    lineRErev = re.compile(r"^\s*-?\s*%s" % "Reverts?:", re.IGNORECASE)
    log.info("Checking commits ...")
    for commit in repo.iter_commits(commit_from+".."+commit_to):
        for line in list(commit.message.split("\n")):
            if lineREres.search(line) or lineRErel.search(line) or lineRErev.search(line):
                for bzID in BZRE.findall(line):
                    try:
                        bzID = int(bzID)
                        bzs[bzID] = 1
                    except ValueError:
                        pass

    log.info("Checking commits: DONE")
    log.info("Removing temporary clone of repository.")
    os.system("rm -rf /tmp/" + pkg_name + "-" + uid)
    return list(bzs.keys())
    
def check_bz(bzid_to_check, bugs):

    log.info("Checking related bug reports ...")
    for bug in bzid_to_check:
        toContinue = False
        while True:
            try:
                bToCheck = bugs.getbug(bug)
                break
            except Exception as e:
                if "502 - Server Proxy Error" not in str(e):
                    log.warning("#" + str(bug) + " - " + str(e))
                    toContinue = True
                    break

        if toContinue == True:
            continue

        # Check if CVE- is in summary of the bug report
        if "CVE-" in bToCheck.summary and bToCheck.resolution != "ERRATA":

            # Check severity and priority to be high or urgent
            if bToCheck.severity == "high" or bToCheck.severity == "urgent":

                # Is current bug for y-stream?
                if (hasattr(bToCheck, 'cf_zstream_target_release') == True and bToCheck.cf_zstream_target_release == "---") or hasattr(bToCheck, 'cf_zstream_target_release') == False:

                    # Separate akk CVE IDs and search for z-stream version of the bug
                    for cveID in CVERE.findall(bToCheck.summary):
                        oneOut = False
                        for otherBug in bugs.query(
                            {'f1': 'cf_zstream_target_release',
                             'o1': 'isnotempty',
                             'product': 'Red Hat Enterprise Linux ' + pkg_platform[2],
                             'query_format': 'advanced',
                             'short_desc': cveID,
                             'short_desc_type': 'substring',
                             'component': pkg_name }):

                            if otherBug.id != bToCheck.id:
                                if otherBug.resolution == "ERRATA":
                                    oneOut = True

                        if oneOut == False:
                            log.error("No z-stream errata has been released for this CVE (" + cveID + ").")
                            print("Deny")
                            log.shutdown
                            return 1
                else:
                    for cveID in CVERE.findall(bToCheck.summary):
                        oneOut = False
                        for otherBug in bugs.query(
                            {'f1': 'cf_zstream_target_release',
                             'o1': 'isnotempty',
                             'product': 'Red Hat Enterprise Linux ' + pkg_platform[2],
                             'query_format': 'advanced',
                             'short_desc': cveID,
                             'short_desc_type': 'substring',
                             'component': pkg_name }):

                            if otherBug.resolution == "ERRATA":
                                oneOut = True
                        if oneOut == False:
                            log.error("No z-stream errata has been released for this CVE (" + cveID + ").")
                            print("Deny")
                            log.shutdown()
                            return 1

    log.info("Checking related bug reports: DONE")
    print("Allow")
    log.shutdown()
    return 0

if __name__ == '__main__':
    
    usage = "usage: python3 %prog NVR"
    parser = optparse.OptionParser(usage)
    parser.add_option("-v", help="Enable log output (INFO)", dest="info", action="store_true", default=False)
    parser.add_option("-d", help="Enable log output (DEBUG)", dest="debug", action="store_true", default=False)

    options, args = parser.parse_args()

    if options.debug == True:
        log.basicConfig(format="%(levelname)s: %(message)s", level=log.DEBUG)
        log.info("Debug output enabled")
    elif options.info == True:
        log.basicConfig(format="%(levelname)s: %(message)s", level=log.INFO)
        log.info("Info output enabled")
    else:
        log.basicConfig(format="%(levelname)s: %(message)s")

    # Brew instance
    brew_proxy = brew.ClientSession("http://brewhub.engineering.redhat.com/brewhub/")

    # Check if argument passed
    if len(args) > 0:
        check_pkg = args[0]
    else:
        parser.error("No NVR passed")
        sys.exit(2)

    pkg_name, pkg_version, pkg_release, pkg_platform = split_rpm_name(check_pkg)
    
    commit_from, commit_to = get_info_from_brew(check_pkg)

    if commit_from == commit_to:
        log.error("Can't make diff against baseline build.")
        sys.exit(2)
 
    bzid_to_check = pull_git_for_pkg(pkg_name, commit_from, commit_to)

    bugs = bz.Bugzilla(url="https://bugzilla.redhat.com")

    sys.exit(check_bz(bzid_to_check, bugs))
