#!/usr/bin/python3
# -*- encoding: utf-8 -*-

import koji as brew
import bugzilla as bz
import logging as log
import optparse
import string
import random
import sys
import git
import os
import re

LAST_NVR = None
COMPLETION_TIME = None
VOLUME_ID = None
BAD_BZS = []
BZRE = re.compile(r"(?:(?:bug|bz|rhbz)\s*#?|#)\s*(\d+)", re.IGNORECASE)
CVERE = re.compile(r"(CVE-[0-9]{4}-[0-9]{4,})", re.IGNORECASE)

def randomString(stringLength):
    letters = string.ascii_letters
    return "".join(random.choice(letters) for i in range(stringLength))

def split_rpm_name(name):
    m = re.search(r'(.*)-(.*)-(.*?)\.(el.*)', name)
    if m:
        (name, version, release, platform) = m.groups()
    else:
        (name, version, release, platform) = split_module_name(name)

    return (name, version, release, platform)

def split_module_name(name):
    m = re.search(r'(.*)-(.*)-(.*?)\+(el.*)', name)
    if m:
        (name, version, release, platform) = m.groups()
        return (name, version, release, platform)
    else:
        log.error('Invalid name: %s\n' % name)
        sys.exit(2)

def atoi(text):
    return int(text) if text.isdigit() else text

def natural_keys(text):
    '''
    alist.sort(key=natural_keys) sorts in human order
    http://nedbatchelder.com/blog/200712/human_sorting.html
    (See Toothy's implementation in the comments)
    '''
    return [ atoi(c) for c in re.split(r'(\d+)', text) ]

def get_info_from_brew(check_pkg):
    global LAST_NVR, COMPLETION_TIME, VOLUME_ID

    log.info("Pulling info about " + check_pkg + " from brew.")

    # Get info about build
    try:
        checked_build = brew_proxy.getBuild(check_pkg)
    except Exception as e:
        log.error("NVR - " + str(e))
        sys.exit(2)

    # Check for output of brew query
    if checked_build == None:
        log.error("Invalid NVR")
        sys.exit(2)

    # Eliminate containers and others
    if "source" not in checked_build['extra']:
        log.error("Only RPM builds allowed.")
        sys.exit(2)

    last_commit = None

    repo_name = re.findall(r'rpms/(.+)#', checked_build['extra']['source']['original_url'])[0]

    # Get info about released versions
    log.info("Pulling info about latest build for " + checked_build['name'] + " from brew.") 
    for entry in brew_proxy.getLatestBuilds('rhel-' + checked_build['release'].split("el")[1][0] + '-latest-build', package=checked_build['name']):
        VOLUME_ID = entry['volume_id']
        LAST_NVR = entry['nvr']
        COMPLETION_TIME = entry['completion_time']
        last_commit = brew_proxy.getBuild(LAST_NVR)['extra']['source']['original_url']

    if last_commit == None:
        log.info("No last NVR.")
        return "", checked_build['extra']['source']['original_url'].split("#")[1], checked_build['package_id'], repo_name
    return last_commit.split("#")[1], checked_build['extra']['source']['original_url'].split("#")[1], checked_build['package_id'], repo_name

def pull_git_for_pkg(pkg_name, commit_from, commit_to, git_dir=None):

    log.info("Making temporary clone of " + pkg_name + " repository. This can take a while.")

    if git_dir == None:
        uid = randomString(10)
        repo = git.Repo.clone_from("git://pkgs.devel.redhat.com/rpms/" + pkg_name + ".git", "/tmp/" + pkg_name + "-" + uid)
    else:
        repo = git.Repo("/tmp/" + git_dir)

    bzs = {}
    lineREres = re.compile(r"^\s*-?\s*%s" % "Resolves?:", re.IGNORECASE)
    lineRErel = re.compile(r"^\s*-?\s*%s" % "Related?:", re.IGNORECASE)
    lineRErev = re.compile(r"^\s*-?\s*%s" % "Reverts?:", re.IGNORECASE)
    log.info("Checking commits ...")
    for commit in repo.iter_commits(commit_from+".."+commit_to):
        for line in list(commit.message.split("\n")):
            if lineREres.search(line) or lineRErel.search(line) or lineRErev.search(line):
                for bzID in BZRE.findall(line):
                    try:
                        bzID = int(bzID)
                        bzs[bzID] = 1
                    except ValueError:
                        pass

    log.info("Checking commits: DONE")

    if git_dir == None:
        return list(bzs.keys()), pkg_name + "-" + uid
    else:
        return list(bzs.keys()), git_dir

def find_previous_released(check_pkg, git_folder, pkg_id, base_commit, repo_name):
    
    global BAD_BZS, LAST_NVR

    builds = {}
    for bld in brew_proxy.listBuilds(pkg_id, state=1, volumeID=VOLUME_ID, completeAfter=COMPLETION_TIME):
        builds[bld['nvr']] = bld
    
    keys = list(builds.keys())
    keys.sort(key=natural_keys)

    prev_index = keys.index(check_pkg)-1 if check_pkg in keys else keys.index(keys[-1])
    if prev_index < 0:
        log.error("No previous suitable build found. Use baseline.")
        print(LAST_NVR)
        return 1

    previous_nvr = keys[prev_index]

    previous_build = builds[previous_nvr]

    if VOLUME_ID == None:
        for tag in brew_proxy.listTags(previous_build['build_id']):
            if "-released" in tag['name']:
                log.info("Following NVR has been released: " + previous_build['nvr'])
                print(previous_build['nvr'])
                return 0

    bz_to_check, git_dir = pull_git_for_pkg(repo_name, base_commit, previous_build['extra']['source']['original_url'].split("#")[1], git_folder)

    skip = False
    for bbz in BAD_BZS:
        if bbz in bz_to_check:
            skip = True
            break;

    if skip == True:
        return find_previous_released(previous_nvr, git_folder, pkg_id, base_commit, repo_name)

    return check_bz(bz_to_check, previous_nvr, git_folder, pkg_id, base_commit, repo_name, False)

def check_bz(bzid_to_check, check_pkg, git_folder, pkg_id, base_commit, repo_name, parent=True):
    global BAD_BZS

    log.info("Checking related bug reports ...")
    for bug in bzid_to_check:
        toContinue = False
        while True:
            try:
                bToCheck = bugs.getbug(bug)
                break
            except Exception as e:
                if "502 Server" not in str(e):
                    log.warning("#" + str(bug) + " - " + str(e))
                    toContinue = True
                    break

        if toContinue == True:
            continue

        # Check if CVE- is in summary of the bug report
        if "CVE-" in bToCheck.summary and bToCheck.resolution != "ERRATA":

            # Check severity and priority to be high or urgent
            if bToCheck.severity == "high" or bToCheck.severity == "urgent":

                # Is current bug for y-stream?
                if (hasattr(bToCheck, 'cf_zstream_target_release') == True and bToCheck.cf_zstream_target_release == "---") or hasattr(bToCheck, 'cf_zstream_target_release') == False:

                    # Separate akk CVE IDs and search for z-stream version of the bug
                    for cveID in CVERE.findall(bToCheck.summary):
                        oneOut = False
                        for otherBug in bugs.query(
                            {'f1': 'cf_zstream_target_release',
                             'o1': 'isnotempty',
                             'product': 'Red Hat Enterprise Linux ' + pkg_platform[2],
                             'query_format': 'advanced',
                             'short_desc': cveID,
                             'short_desc_type': 'substring',
                             'component': pkg_name }):

                            if otherBug.id != bToCheck.id:
                                if otherBug.resolution == "ERRATA":
                                    oneOut = True

                        if oneOut == False:
                            log.error("No z-stream errata has been released for this CVE (" + cveID + ").")
                            BAD_BZS.append(bug) 
                            find_previous_released(check_pkg, git_folder, pkg_id, base_commit, repo_name)
                            if parent == True:
                                log.info("Removing temporary clone of repository.")
                                os.system("rm -rf /tmp/" + git_folder)
                                log.shutdown()
                            return 1
                else:
                    for cveID in CVERE.findall(bToCheck.summary):
                        oneOut = False
                        for otherBug in bugs.query(
                            {'f1': 'cf_zstream_target_release',
                             'o1': 'isnotempty',
                             'product': 'Red Hat Enterprise Linux ' + pkg_platform[2],
                             'query_format': 'advanced',
                             'short_desc': cveID,
                             'short_desc_type': 'substring',
                             'component': pkg_name }):

                            if otherBug.resolution == "ERRATA":
                                oneOut = True
                        if oneOut == False:
                            log.error("No z-stream errata has been released for this CVE (" + cveID + ").")
                            BAD_BZS.append(bug)
                            find_previous_released(check_pkg, git_folder, pkg_id, base_commit, repo_name)
                            if parent == True:
                                log.info("Removing temporary clone of repository.")
                                os.system("rm -rf /tmp/" + git_folder)
                                log.shutdown()
                            return 1

    log.info("Checking related bug reports: DONE")
    log.info("NVR " + check_pkg + " allowed.")
    print(check_pkg)
    if parent == True:
       log.info("Removing temporary clone of repository.")
       os.system("rm -rf /tmp/" + git_folder)
       log.shutdown()
    return 0

def check_nvr(check_pkg):
    commit_from, commit_to, pkg_id, repo_name = get_info_from_brew(check_pkg)

    if commit_from == commit_to:
        log.info("Current NVR is identical with released baseline.")
        print(check_pkg)
        log.shutdown()
        return 0

    bzid_to_check, git_folder = pull_git_for_pkg(repo_name, commit_from, commit_to)

    return check_bz(bzid_to_check, check_pkg, git_folder, pkg_id, commit_from, repo_name)

if __name__ == '__main__':

    usage = "usage: python3 %prog NVR"
    parser = optparse.OptionParser(usage)
    parser.add_option("-v", help="Enable log output (INFO)", dest="info", action="store_true", default=False)
    parser.add_option("-d", help="Enable log output (DEBUG)", dest="debug", action="store_true", default=False)

    options, args = parser.parse_args()

    if options.debug == True:
        log.basicConfig(format="%(levelname)s: %(message)s", level=log.DEBUG)
        log.info("Debug output enabled")
    elif options.info == True:
        log.basicConfig(format="%(levelname)s: %(message)s", level=log.INFO)
        log.info("Info output enabled")
    else:
        log.basicConfig(format="%(levelname)s: %(message)s")

    # Brew instance
    brew_proxy = brew.ClientSession("http://brewhub.engineering.redhat.com/brewhub/")

    # Check if argument passed
    if len(args) > 0:
        check_pkg = args[0]
    else:
        parser.error("No NVR passed")
        log.shutdown()
        sys.exit(2)

    pkg_name, pkg_version, pkg_release, pkg_platform = split_rpm_name(check_pkg)

    bugs = bz.Bugzilla(url="https://bugzilla.redhat.com")

    sys.exit(check_nvr(check_pkg))
