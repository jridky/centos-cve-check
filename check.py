#!/usr/bin/python3
# -*- encoding: utf-8 -*-

import koji as brew
import bugzilla as bz
import optparse
import string
import random
import sys
import git
import os
import re

ZSTREAM = None
LAST_NVR = None
NVRS = {}
NVRSZ = {}
BZRE = re.compile(r"(?:(?:bug|bz|rhbz)\s*#?|#)\s*(\d+)", re.IGNORECASE)
CVERE = re.compile(r"(CVE-[0-9]{4}-[0-9]{4,})", re.IGNORECASE)

def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

def randomString(stringLength):
    letters = string.ascii_letters
    return "".join(random.choice(letters) for i in range(stringLength))

def split_filename(name):
    m = re.search(r'(.*)-(.*)-(.*?)\.(el.*)', name)
    if m:
        (name, version, release, platform) = m.groups()
        return (name, version, release, platform)
    else:   
        sys.stderr.write('ERROR: Invalid name: %s\n' % name)
        sys.exit(2)

def atoi(text):
    return int(text) if text.isdigit() else text

def natural_keys(text):
    '''
    alist.sort(key=natural_keys) sorts in human order
    http://nedbatchelder.com/blog/200712/human_sorting.html
    (See Toothy's implementation in the comments)
    '''
    return [ atoi(c) for c in re.split(r'(\d+)', text) ]

def get_tagged_builds(brew_proxy, tag):
    '''
    Return a list of latest builds that are tagged with certain tag
    '''
    return brew_proxy.listTagged(tag)

def get_info_from_brew(check_pkg):
    global ZSTREAM, NVRS, NVRSZ, LAST_NVR

    print("Pulling info about " + check_pkg + " from brew.")

    # Get info about build
    try:
        checked_build = brew_proxy.getBuild(check_pkg) 
    except Exception as e:
        eprint("ERROR: NVR - " + str(e))
        sys.exit(2)

    # Check for output of brew query
    if checked_build == None:
        eprint("ERROR: Invalid NVR")
        sys.exit(2)

    # Eliminate containers and others
    if "source" not in checked_build['extra']:
        eprint("ERROR: Only RPM builds allowed.")
        sys.exit(2)
   
    package_tags = brew_proxy.listTags(check_pkg)

    # Check for z-stream tags   
    ZSTREAM = False
    ztags = {}
    tags = {}
    for tag in package_tags:
        if "-z-candidate" in tag['name']:
            ZSTREAM = True
            ztags[tag['name']] = 1
            break

        if "-candidate" in tag['name'] and tag['name'] not in ztags:
            tags[tag['name']] = 1

    # Get info about released versions
    NVRS = {}
    NVRSZ = {}

    print("Pulling info about other builds of " + check_pkg + " from brew. This can take a while.") 
    i = 0
    for entry in brew_proxy.listBuilds(packageID=checked_build['package_id']):

       sys.stdout.write("\rFetching info about released versions: " + loading[i%4])
       i = i+1

       # We're interested in el8 builds only, which completed successfully
       if "el8" in entry['release'] and entry['state'] == 1:

           found_released = found_zstream = False
           # Get list of tags for current build
           for tag in brew_proxy.listTags(entry['nvr']):

                # Only released builds are interesting                
                if "-released" in tag['name']:
                    found_released = True
                    tags[tag['name']] = 1

                if "-z-candidate" in tag['name']:
                    found_zstream = True
                    ztags[tag['name']] = 1

           if found_released == True:
               if found_zstream == True:
                   NVRSZ[entry['nvr']] = {"build_id": entry['build_id'], "source": entry['extra']['source']['original_url']}
               else:
                   NVRS[entry['nvr']] = {"build_id": entry['build_id'], "source": entry['extra']['source']['original_url']}
                

    sys.stdout.write("\rFetching info about released versions: DONE\n")

    # Get processed NVRs and sort them naturally
    keys = list(NVRS.keys())
    keysz = list(NVRSZ.keys())

    keys.sort(key=natural_keys)
    keysz.sort(key=natural_keys)

    # We're interested in the last one only -> our Base line
    if ZSTREAM == True:
        if len(keysz) > 0:
            LAST_NVR = keysz[-1]
            last_commit = NVRSZ[LAST_NVR]['source']
        else:
            LAST_NVR = keys[-1]
            last_commit = NVRS[LAST_NVR]['source']
    else:
        LAST_NVR = keys[-1]
        last_commit = NVRS[LAST_NVR]['source']

    return last_commit.split("#")[1], checked_build['extra']['source']['original_url'].split("#")[1], list(tags.keys()) + list(ztags.keys())

def pull_git_for_pkg(pkg_name, commit_from, commit_to):

    print("Making temporary clone of " + pkg_name + " repository. This can take a while.")

    uid = randomString(10)
    repo = git.Repo.clone_from("git://pkgs.devel.redhat.com/rpms/" + pkg_name + ".git", "/tmp/" + pkg_name + "-" + uid)

    i = 0   
    bzs = {}
    lineREres = re.compile(r"^\s*-?\s*%s" % "Resolves?:", re.IGNORECASE)
    lineRErel = re.compile(r"^\s*-?\s*%s" % "Related?:", re.IGNORECASE)
    lineRErev = re.compile(r"^\s*-?\s*%s" % "Reverts?:", re.IGNORECASE)
    for commit in repo.iter_commits(commit_from+".."+commit_to):
        sys.stdout.write("\rChecking commits: " + loading[i%4])
        i = i + 1
        for line in list(commit.message.split("\n")):
            if lineREres.search(line) or lineRErel.search(line) or lineRErev.search(line):
                for bzID in BZRE.findall(line):
                    try:
                        bzID = int(bzID)
                        bzs[bzID] = 1
                    except ValueError:
                        pass

    print("\rChecking commits: DONE")
    print("Removing temporary clone of repository.")
    os.system("rm -rf /tmp/" + pkg_name + "-" + uid)
    return list(bzs.keys())
    
def check_bz(bzid_to_check, bugs):

    i = 0
    for bug in bzid_to_check:
        sys.stdout.write("\rChecking info about related bug reports: " + loading[i%4])
        i = i + 1
        try:
            bToCheck = bugs.getbug(bug)
        except Exception as e:
            eprint("\nWARNING: #" + str(bug) + " - " + str(e))
            continue

        # Check if CVE- is in summary of the bug report
        if "CVE-" in bToCheck.summary:

            # Check severity and priority to be high or urgent
            if bToCheck.severity == "high" or bToCheck.priority == "high" or \
               bToCheck.severity == "urgent" or bToCheck.priority == "urgent":

                # Is current bug for y-stream?
                if (hasattr(bToCheck, 'cf_zstream_target_release') == True and bToCheck.cf_zstream_target_release == "---") or hasattr(bToCheck, 'cf_zstream_target_release') == False:

                    # Separate akk CVE IDs and search for z-stream version of the bug
                    for cveID in CVERE.findall(bToCheck.summary):
                        hasBugs = False
                        
                        for otherBug in bugs.query(
                            {'f1': 'cf_zstream_target_release',
                             'o1': 'isnotempty',
                             'product': 'Red Hat Enterprise Linux ' + pkg_platform[2],
                             'query_format': 'advanced',
                             'short_desc': cveID,
                             'short_desc_type': 'substring',
                             'component': pkg_name }):

                            if otherBug.id != bToCheck.id:
                                hasBugs = True

                                if otherBug.resolution != "ERRATA":
                                    eprint("\nBug #" + str(otherBug.id) + " has to be in state CLOSED ERRATA. Deny.")
                                    return 1

                        if hasBugs == False:
                            eprint("\nThis CVE bug (#" + str(bToCheck.id) + ") doesn't have its z-stream. Deny.")
                            return 1
                else:
                    eprint("\nNot sure, if I should allow it. Deny.")
                    return 1
    sys.stdout.write("\rChecking info about related bug reports: DONE\n")
    print("All looks ok. Go on.")
    return 0

if __name__ == '__main__':
    
    loading = ["\\", "|", "/", "-"]

    usage = "usage: python3 %prog NVR"
    parser = optparse.OptionParser(usage)

    options, args = parser.parse_args()

    # Brew instance
    brew_proxy = brew.ClientSession("http://brewhub.engineering.redhat.com/brewhub/")

    # Check if argument passed
    if len(args) > 0:
        check_pkg = args[0]
    else:
        parser.error("No NVR passed")
        sys.exit(2)

    pkg_name, pkg_version, pkg_release, pkg_platform = split_filename(check_pkg)
    
    commit_from, commit_to, release = get_info_from_brew(check_pkg)

    if commit_from == commit_to:
        eprint("ERROR: Can't make diff against baseline build.")
        sys.exit(2)
 
    bzid_to_check = pull_git_for_pkg(pkg_name, commit_from, commit_to)

    bugs = bz.Bugzilla(url="https://bugzilla.redhat.com")

    sys.exit(check_bz(bzid_to_check, bugs))
